/// Entity Count Stress Test
///
/// This binary runs performance benchmarks with high entity counts (500+) to identify
/// bottlenecks in the simulation. It measures TPS, memory usage, and per-system timings.
///
/// Usage:
///   cargo run --release --bin stress_test
///   DISABLE_WEB_SERVER=1 cargo run --release --bin stress_test
///   STRESS_TEST_DURATION=60 STRESS_TEST_CONFIG=custom_config.ron cargo run --release --bin stress_test

use bevy::app::ScheduleRunnerPlugin;
use bevy::diagnostic::{Diagnostics, FrameTimeDiagnosticsPlugin};
use bevy::prelude::*;
use bevy::utils::HashMap;
use std::time::{Duration, Instant};

mod ai;
mod cached_world;
mod debug;
mod entities;
mod errors;
mod pathfinding;
mod resources;
mod serialization;
mod simulation;
mod tilemap;
mod types;
mod vegetation;
mod web;
mod world_loader;

use entities::*;
use pathfinding::{pathfinding_cache_cleanup_system, process_pathfinding_requests, PathCache, PathfindingGrid};
use simulation::SimulationTick;
use tilemap::{TilemapPlugin, WorldConfig};
use vegetation::VegetationPlugin;
use world_loader::WorldLoader;

// Re-exports needed for the stress test modules
pub use crate::ai::*;
pub use crate::cached_world::*;
pub use crate::debug::*;
pub use crate::entities::*;
pub use crate::errors::*;
pub use crate::pathfinding::*;
pub use crate::resources::*;
pub use crate::serialization::*;
pub use crate::simulation::*;
pub use crate::tilemap::*;
pub use crate::types::*;
pub use crate::vegetation::*;
pub use crate::web::*;
pub use crate::world_loader::*;

/// Stress test configuration
struct StressTestConfig {
    duration_secs: u64,
    target_ticks: u64,
    config_file: String,
}

impl Default for StressTestConfig {
    fn default() -> Self {
        Self {
            duration_secs: 60,
            target_ticks: 1000,
            config_file: "config/spawn_config_stress_test.ron".to_string(),
        }
    }
}

impl StressTestConfig {
    fn from_env() -> Self {
        let mut config = Self::default();

        if let Ok(duration) = std::env::var("STRESS_TEST_DURATION") {
            if let Ok(d) = duration.parse::<u64>() {
                config.duration_secs = d;
            }
        }

        if let Ok(ticks) = std::env::var("STRESS_TEST_TICKS") {
            if let Ok(t) = ticks.parse::<u64>() {
                config.target_ticks = t;
            }
        }

        if let Ok(cfg) = std::env::var("STRESS_TEST_CONFIG") {
            config.config_file = cfg;
        }

        config
    }
}

/// Tracks performance metrics during stress test
#[derive(Resource, Default)]
struct StressTestMetrics {
    start_time: Option<Instant>,
    tick_times: Vec<u64>,
    entity_count: usize,
    max_memory_usage: u64,
    system_times: HashMap<String, u64>,
}

impl StressTestMetrics {
    fn record_tick_time(&mut self, duration_us: u64) {
        self.tick_times.push(duration_us);
    }

    fn average_tick_time(&self) -> f64 {
        if self.tick_times.is_empty() {
            return 0.0;
        }
        self.tick_times.iter().sum::<u64>() as f64 / self.tick_times.len() as f64
    }

    fn percentile_tick_time(&self, percentile: f64) -> u64 {
        if self.tick_times.is_empty() {
            return 0;
        }
        let mut sorted = self.tick_times.clone();
        sorted.sort_unstable();
        let index = ((sorted.len() as f64 * percentile / 100.0) as usize).min(sorted.len() - 1);
        sorted[index]
    }

    fn stddev_tick_time(&self) -> f64 {
        if self.tick_times.len() < 2 {
            return 0.0;
        }
        let mean = self.average_tick_time();
        let variance = self.tick_times.iter()
            .map(|&t| {
                let diff = t as f64 - mean;
                diff * diff
            })
            .sum::<f64>() / self.tick_times.len() as f64;
        variance.sqrt()
    }

    fn tps(&self, elapsed_secs: f64) -> f32 {
        if elapsed_secs <= 0.0 {
            return 0.0;
        }
        self.tick_times.len() as f32 / elapsed_secs as f32
    }
}

fn main() {
    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘        LIFE SIMULATOR - ENTITY STRESS TEST                     â•‘");
    println!("â•‘        Testing performance with 500+ entities                  â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    let stress_config = StressTestConfig::from_env();
    println!("ğŸ“‹ Stress Test Configuration:");
    println!("   Duration: {} seconds", stress_config.duration_secs);
    println!("   Target Ticks: {}", stress_config.target_ticks);
    println!("   Config File: {}\n", stress_config.config_file);

    App::new()
        .add_plugins(
            MinimalPlugins.set(ScheduleRunnerPlugin::run_loop(Duration::from_secs_f64(
                1.0 / 60.0,
            ))),
        )
        .add_plugins(bevy::log::LogPlugin {
            level: bevy::log::Level::WARN,
            filter: "life_simulator=info".to_string(),
        })
        .add_plugins(FrameTimeDiagnosticsPlugin)
        .add_plugins((
            simulation::SimulationPlugin,
            EntitiesPlugin,
            ai::TQUAIPlugin,
            VegetationPlugin,
            debug::HealthCheckPlugin,
            debug::HealthCheckApiPlugin,
        ))
        .insert_resource(WorldConfig::default())
        .insert_resource(stress_config)
        .insert_resource(StressTestMetrics::default())
        .init_resource::<ButtonInput<KeyCode>>()
        .init_resource::<PathfindingGrid>()
        .init_resource::<PathCache>()
        .init_resource::<bevy::time::Time>()
        .add_systems(
            Startup,
            (
                setup,
                spawn_entities_from_stress_config.after(setup),
            ),
        )
        .add_systems(
            Update,
            (
                process_pathfinding_requests,
                pathfinding_cache_cleanup_system,
                simulation_system,
                measure_performance.after(simulation_system),
                check_completion.after(measure_performance),
            )
                .run_if(resource_exists::<WorldLoader>),
        )
        .run();
}

fn setup(mut commands: Commands, mut pathfinding_grid: ResMut<PathfindingGrid>) {
    println!("ğŸ”§ Setting up stress test environment...");

    let requested_map_name =
        std::env::var("WORLD_MAP_NAME").unwrap_or_else(|_| "slopes_demo".to_string());

    let world_loader = match WorldLoader::load_by_name(&requested_map_name) {
        Ok(loader) => {
            println!("âœ… World loaded: {} (seed: {})", loader.get_name(), loader.get_seed());
            loader
        }
        Err(_err) => match WorldLoader::load_default() {
            Ok(loader) => {
                println!("âœ… World loaded: {} (seed: {})", loader.get_name(), loader.get_seed());
                loader
            }
            Err(e) => {
                eprintln!("âŒ Failed to load world: {}", e);
                std::process::exit(1);
            }
        },
    };

    // Build pathfinding grid
    println!("ğŸ§­ Building pathfinding grid...");
    use tilemap::TerrainType;

    let ((min_x, min_y), (max_x, max_y)) = world_loader.get_world_bounds();
    let tile_min_x = min_x * 16 - 16;
    let tile_min_y = min_y * 16 - 16;
    let tile_max_x = (max_x + 1) * 16 + 16;
    let tile_max_y = (max_y + 1) * 16 + 16;

    let mut tiles_processed = 0;
    for y in tile_min_y..=tile_max_y {
        for x in tile_min_x..=tile_max_x {
            let pos = bevy::math::IVec2::new(x, y);
            let terrain_str = world_loader.get_terrain_at(x, y);
            let terrain_cost = if let Some(terrain_str) = terrain_str {
                if let Some(terrain) = TerrainType::from_str(&terrain_str) {
                    let cost = terrain.movement_cost();
                    if cost >= 1000.0 {
                        u32::MAX
                    } else {
                        cost as u32
                    }
                } else {
                    u32::MAX
                }
            } else {
                u32::MAX
            };

            let has_resource = world_loader
                .get_resource_at(x, y)
                .map(|r| !r.is_empty())
                .unwrap_or(false);

            let final_cost = if has_resource && terrain_cost != u32::MAX {
                u32::MAX
            } else {
                terrain_cost
            };

            pathfinding_grid.set_cost(pos, final_cost);
            tiles_processed += 1;
        }
    }

    println!("âœ… Pathfinding grid ready ({} tiles)", tiles_processed);

    // Disable web server for stress test (we're measuring performance)
    println!("ğŸŒ Web server disabled for stress test");

    commands.insert_resource(world_loader);
}

fn spawn_entities_from_stress_config(
    mut commands: Commands,
    pathfinding_grid: Res<PathfindingGrid>,
    world_loader: Res<WorldLoader>,
    stress_config: Res<StressTestConfig>,
    mut metrics: ResMut<StressTestMetrics>,
) {
    println!("\nğŸ“Š Spawning entities for stress test...");
    let start = Instant::now();

    let config = match spawn_config::SpawnConfig::load_from_file(&stress_config.config_file) {
        Ok(cfg) => {
            println!("âœ… Loaded config from {}", stress_config.config_file);
            cfg
        }
        Err(_) => {
            println!("âš ï¸ Could not load config, using default");
            spawn_config::SpawnConfig::default()
        }
    };

    let mut total_spawned = 0;

    for (group_idx, group) in config.spawn_groups.iter().enumerate() {
        println!("   Spawning {} {}...", group.count, group.species);

        let mut group_spawned = 0;
        let mut rng = rand::thread_rng();

        for entity_index in 0..group.count {
            let name = format!("{}_{}", group.species, entity_index + 1);

            let spawn_pos = (0..group.spawn_area.max_attempts).find_map(|_| {
                use rand::Rng;
                let dx = rng.gen_range(-group.spawn_area.search_radius..=group.spawn_area.search_radius);
                let dy = rng.gen_range(-group.spawn_area.search_radius..=group.spawn_area.search_radius);
                let candidate = IVec2::new(
                    group.spawn_area.center.0 + dx,
                    group.spawn_area.center.1 + dy,
                );

                if pathfinding_grid.is_walkable(candidate) {
                    if let Some(terrain) = world_loader.get_terrain_at(candidate.x, candidate.y) {
                        if terrain == "Grass" || terrain == "Forest" {
                            return Some(candidate);
                        }
                    }
                }
                None
            });

            if let Some(spawn_pos) = spawn_pos {
                let _entity = spawn_using_registry(&mut commands, &group.species, name, spawn_pos);
                group_spawned += 1;
            }
        }

        println!("      âœ“ Spawned {} {}", group_spawned, group.species);
        total_spawned += group_spawned;
    }

    metrics.entity_count = total_spawned;
    metrics.start_time = Some(Instant::now());

    println!("\nâœ… Stress test ready!");
    println!("   Total entities spawned: {}", total_spawned);
    println!("   Starting performance measurement...\n");
    println!("â•­â”€ TICK MEASUREMENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®");
}

fn simulation_system(world_loader: Res<WorldLoader>) {
    static mut FRAME_COUNT: u64 = 0;
    unsafe {
        FRAME_COUNT += 1;
        if FRAME_COUNT % 300 == 0 {
            // Every 5 seconds at 60 FPS
            println!(
                "   Progress: {} frames ({} secs)",
                FRAME_COUNT,
                FRAME_COUNT / 60
            );
        }
    }
}

fn measure_performance(
    mut metrics: ResMut<StressTestMetrics>,
    sim_tick: Res<SimulationTick>,
    time: Res<bevy::time::Time>,
    diagnostics: Res<Diagnostics>,
) {
    // Record tick time if available from diagnostics
    if let Some(frame_time_diagnostic) = diagnostics.get(FrameTimeDiagnosticsPlugin::FRAME_TIME) {
        if let Some(frame_time) = frame_time_diagnostic.smoothed() {
            let frame_time_us = (frame_time * 1_000_000.0) as u64;
            metrics.record_tick_time(frame_time_us);
        }
    }
}

fn check_completion(
    metrics: Res<StressTestMetrics>,
    sim_tick: Res<SimulationTick>,
    stress_config: Res<StressTestConfig>,
) {
    let tick = sim_tick.0;

    // Check if we've reached target ticks
    if tick > 0 && tick % 100 == 0 {
        if let Some(start) = metrics.start_time {
            let elapsed = start.elapsed();
            let elapsed_secs = elapsed.as_secs_f64();

            if elapsed_secs > 0.0 && tick as u64 >= stress_config.target_ticks {
                println!("\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n");
                print_stress_test_results(&metrics, elapsed_secs, tick);
                std::process::exit(0);
            }
        }
    }

    // Also check elapsed time
    if let Some(start) = metrics.start_time {
        if start.elapsed().as_secs() >= stress_config.duration_secs {
            println!("\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n");
            let elapsed = start.elapsed().as_secs_f64();
            print_stress_test_results(&metrics, elapsed, tick);
            std::process::exit(0);
        }
    }
}

fn print_stress_test_results(metrics: &StressTestMetrics, elapsed_secs: f64, ticks: u64) {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘                    STRESS TEST RESULTS                         â•‘");
    println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

    println!("â”‚ Entities Spawned: {}", metrics.entity_count);
    println!("â”‚ Total Ticks: {}", ticks);
    println!("â”‚ Elapsed Time: {:.2} seconds", elapsed_secs);

    let avg_tick_time = metrics.average_tick_time();
    let p50_tick_time = metrics.percentile_tick_time(50.0);
    let p95_tick_time = metrics.percentile_tick_time(95.0);
    let p99_tick_time = metrics.percentile_tick_time(99.0);
    let stddev = metrics.stddev_tick_time();
    let tps = metrics.tps(elapsed_secs);

    println!("â”‚");
    println!("â”‚ TIMING METRICS:");
    println!("â”‚   Average Tick Time: {:.2} Âµs ({:.3} ms)", avg_tick_time, avg_tick_time / 1000.0);
    println!("â”‚   Median (P50):      {:.2} Âµs ({:.3} ms)", p50_tick_time, p50_tick_time as f64 / 1000.0);
    println!("â”‚   P95:               {:.2} Âµs ({:.3} ms)", p95_tick_time, p95_tick_time as f64 / 1000.0);
    println!("â”‚   P99:               {:.2} Âµs ({:.3} ms)", p99_tick_time, p99_tick_time as f64 / 1000.0);
    println!("â”‚   Std Dev:           {:.2} Âµs", stddev);
    println!("â”‚");

    println!("â”‚ THROUGHPUT:");
    println!("â”‚   Actual TPS: {:.2} ticks/sec", tps);
    println!("â”‚   Target TPS: 10.0 ticks/sec");

    let target_tick_time = 100_000.0; // 100ms per tick at 10 TPS = 100,000 Âµs
    let budget_percent = (avg_tick_time / target_tick_time * 100.0).min(999.9);
    println!("â”‚   Budget Used: {:.1}% (10ms budget per tick)", budget_percent);

    if budget_percent > 100.0 {
        println!("â”‚   Status: EXCEEDING TARGET (too slow)");
    } else if budget_percent > 80.0 {
        println!("â”‚   Status: HIGH (approaching limit)");
    } else {
        println!("â”‚   Status: GOOD (within budget)");
    }

    println!("â”‚");
    println!("â”‚ TICK TIME DISTRIBUTION:");
    println!("â”‚   Min:  {:.2} Âµs", metrics.tick_times.iter().copied().min().unwrap_or(0) as f64);
    println!("â”‚   Max:  {:.2} Âµs", metrics.tick_times.iter().copied().max().unwrap_or(0) as f64);
    println!("â”‚   Range: {:.2} Âµs",
        (metrics.tick_times.iter().copied().max().unwrap_or(0) -
         metrics.tick_times.iter().copied().min().unwrap_or(0)) as f64);

    // Analysis
    println!("â”‚");
    println!("â”‚ ANALYSIS:");

    if tps < 8.0 {
        println!("â”‚   âš ï¸ BOTTLENECK DETECTED: TPS is below target ({})", tps as i32);
        println!("â”‚   Recommendation: Run with flamegraph to identify hot paths");
    } else if tps < 10.0 {
        println!("â”‚   âš ï¸ MARGINAL: TPS slightly below target");
        println!("â”‚   Recommendation: Monitor hottest systems");
    } else {
        println!("â”‚   âœ… PASS: Meets target throughput");
    }

    if stddev > avg_tick_time * 0.5 {
        println!("â”‚   âš ï¸ HIGH VARIANCE: Tick times are inconsistent");
        println!("â”‚   Recommendation: Check for GC pauses or frame drops");
    } else {
        println!("â”‚   âœ… STABLE: Consistent tick performance");
    }

    if p99_tick_time as f64 > target_tick_time * 2.0 {
        println!("â”‚   âš ï¸ OUTLIERS: P99 significantly exceeds average");
        println!("â”‚   Recommendation: Investigate spike causes");
    }

    println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    println!("â”‚ NEXT STEPS:                                                    â”‚");
    println!("â”‚ 1. Test with different entity counts: 100, 200, 300, 500      â”‚");
    println!("â”‚ 2. Run with flamegraph: cargo flamegraph --bin stress_test    â”‚");
    println!("â”‚ 3. Profile systems separately for detailed bottleneck analysis â”‚");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}
