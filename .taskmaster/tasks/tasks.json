{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Refactor world data schema for biome and elevation support",
        "description": "Extend the serialized world format and configuration objects to capture biome, elevation, and vegetation metadata required by the advanced generator.",
        "details": "Update `src/serialization.rs`, `src/world_loader.rs`, and `src/cached_world.rs` to add `biome_config`, `elevation_map`, `vegetation_density`, and related fields described in the PRD. Introduce strongly typed structs (e.g., `BiomeConfig`, `ElevationStatistics`) and update `WorldConfig` defaults in `src/tilemap/world_generator.rs` to reference the new data. Ensure `map_generator` writes new layers (\"biome\", \"elevation\", \"vegetation_density\") to `SerializedChunk.layers` while preserving backward compatibility for legacy saves.\n\nPseudo-code:\n```rust\n#[derive(Serialize, Deserialize, Clone)]\npub struct SerializedWorld {\n    name: String,\n    seed: u64,\n    config: WorldConfig,\n    biome_config: BiomeConfig,\n    elevation_map: HashMap<String, f32>,\n    chunks: HashMap<String, SerializedChunk>,\n    version: String,\n}\n```\n\nAdd migration helpers that default missing fields when loading old files and expose getters in `WorldLoader` for new layers.",
        "testStrategy": "Add serialization round-trip tests in `tests/serialization_roundtrip.rs` verifying RON files with and without the new fields still load. Create a golden fixture for a generated world including new layers and assert `WorldLoader` exposes biome/elevation data. Run `cargo test serialization` to confirm regression coverage.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement temperate biome classification noise pipeline",
        "description": "Replace the placeholder biome logic with a moisture–temperature driven system that yields the PRD’s woodland–grassland biome set.",
        "details": "Revise `src/tilemap/biome.rs` to enumerate the PRD’s biome types (TemperateForest, Woodland, Grassland, ForestEdge, RiparianZone, RockyOutcrop, ShallowWater, DeepWater). Integrate `noise` crate (Simplex + Perlin) in `BiomeGenerator` for multi-octave moisture and temperature maps, plus elevation influence. Inject `BiomeGenerator` into `map_generator` so each chunk receives a biome layer and store weighted blends for transition tiles. Ensure biome metadata (preferred terrain probabilities, resource potential) reflects ecological notes from the PRD.\n\nPseudo-code:\n```rust\nlet moisture = simplex(seed.moisture, chunk_pos * MOISTURE_SCALE);\nlet temperature = perlin(seed.temperature, chunk_pos * TEMP_SCALE) + latitude_gradient;\nlet elevation = elevation_map.sample(chunk_pos);\nlet biome = select_biome(moisture, temperature, elevation);\nbiome_layer[y][x] = biome.to_string();\n```\n\nExpose helper APIs so simulation systems can query preferred biome for a tile.",
        "testStrategy": "Add unit tests for `BiomeType::from_climate` ensuring moisture/temperature/elevation combinations map to the expected biome. Generate a small world in an integration test and assert all biome strings are within the new enum set. Optionally render a debug ASCII map to confirm transitions.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Generate elevation maps with slope-aware terrain selection",
        "description": "Introduce a dedicated elevation generator that shapes hills, valleys, and influences terrain walkability per the PRD.",
        "details": "Create `ElevationGenerator` in `src/map_generator.rs` or a new module under `src/tilemap/` that builds multi-octave heightmaps using `noise` (ridged + perlin). Normalize to 0..1, cache per chunk, and inject into terrain generation so slopes alter terrain types (rocky outcrops at high elevation, shallow gradients for meadows). Emit an `\"elevation\"` layer and store slope metadata for river routing.\n\nPseudo-code:\n```rust\nlet elevation = elevation_generator.sample(world_x, world_y);\nlet slope = elevation_generator.local_slope(world_x, world_y);\nmatch (elevation, slope) {\n    (h, _) if h > 0.85 => TerrainType::Mountains,\n    (_, s) if s > STEEP_THRESHOLD => TerrainType::RockyGround,\n    _ => biome.select_terrain(rng.rand()),\n}\n```\n\nUpdate `WorldStatistics` to track elevation stats for API reporting.",
        "testStrategy": "Write deterministic tests that sample known coordinates and assert monotonic elevation gradients. Add an integration test that ensures the produced elevation layer contains values in range and that high elevation correlates with RockyOutcrop terrain. Validate with `cargo test elevation` and a CLI run of `map_generator --radius 2 --verbose`.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement river generation with tributaries and riparian tagging",
        "description": "Add a river system that routes downhill from elevated sources, branches naturally, and labels riparian zones for vegetation and AI.",
        "details": "Introduce `RiverGenerator` invoked from `map_generator`. Seed river sources at high elevations, run a downhill pathfinding (A*/greedy) to low basins, merge tributaries, and vary width to map shallow vs. deep water tiles. Mark adjacent tiles as `RiparianZone` in the biome layer and update terrain to water types. Persist river metadata so simulation can distinguish banks.\n\nPseudo-code:\n```rust\nfor source in elevation_map.select_sources(NUM_RIVER_SOURCES) {\n    let mut path = downhill_flow(&elevation_map, source);\n    widen_channel(&mut layers, &path, width_curve(path.len()));\n    tag_riparian(&mut biome_layer, &path, RIVER_BANK_RADIUS);\n}\n```\n\nEnsure serialization writes river width info if needed for visualization.",
        "testStrategy": "Add integration tests generating a sample world and asserting every river path starts above a height threshold and ends below it, with no orphan segments. Verify riparian tiles exist along river banks. Use a quick snapshot test storing coordinates of generated rivers for determinism under fixed seed.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement biome-aware vegetation placement and density layers",
        "description": "Create vegetation density maps and place flora according to biome rules to satisfy herbivore food requirements.",
        "details": "Expand `ResourceGenerator` in `src/resources.rs` to accept biome and elevation context. For each chunk, compute vegetation density maps (trees, bushes, grass, flowers) using clustering algorithms (Poisson disk or noise-based). Populate new `\"vegetation_density\"` layer and spawn resource entries aligned with PRD descriptions (clusters in forests, scattered in woodlands, riparian lushness). Balance densities to support herbivore biomass targets.\n\nPseudo-code:\n```rust\nfor tile in chunk.iter_tiles() {\n    let biome = biome_layer[tile];\n    let density = vegetation_profile.lookup(biome);\n    if rng.chance(density.tree_density) { layers[\"resources\"][tile] = ResourceType::TreeOak; }\n    vegetation_density_layer[tile] = density.normalized();\n}\n```\n\nUpdate spawn configs in `config/spawn_config.ron` to reflect new resource IDs.",
        "testStrategy": "Unit-test biome lookup tables to confirm densities sum within expected ranges. Create an integration test that counts vegetation per biome for a deterministic seed and compares against expected bounds. Run `cargo run --bin map_generator -- --seed 42 --radius 4` and visually inspect resource counts to validate clustering.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Balance ecological resource distribution and spawn recommendations",
        "description": "Leverage new vegetation data to calculate food/water availability and share spawn guidance for species balancing.",
        "details": "Augment `src/resources.rs` and introduce a `ResourceAnalytics` helper that scans generated layers to compute per-biome biomass, nearest water distances, and recommended spawn densities. Serialize this summary into the world file (e.g., `SerializedWorld.resource_summary`) so the simulator and tooling can reference it. Update `src/entities/spawn_config.rs` to optionally consume these recommendations when seeding worlds.\n\nPseudo-code:\n```rust\nlet summary = ResourceSummary::from_layers(&layers);\nsummary.recommended_spawn[Species::Deer] = summary.biome_food(\"Grassland\") / DEER_DAILY_INTAKE;\nworld.resource_summary = summary;\n```\n\nProvide CLI logging in `map_generator` to highlight imbalances.",
        "testStrategy": "Write analytics tests that feed synthetic layers and assert the summary outputs accurate biomass and water coverage. Add an integration test that runs the generator and verifies the recommended spawn counts are non-zero and scale with biome area. Use `cargo test resource_summary` plus a manual regression run to verify CLI output.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Adapt simulation pathfinding and movement to biome-aware terrain costs",
        "description": "Update the headless simulator to consume biome, elevation, and river data for movement costs and habitat preferences.",
        "details": "Modify `src/pathfinding.rs` and the `PathfindingGrid` builder in `src/main.rs` to ingest new layers from `WorldLoader`, assigning species-specific costs (e.g., deer favor Grassland, wolves prefer Forest, rivers costly unless shallow). Extend `tilemap::TerrainType` and `BehaviorConfig` (`src/entities/types/*.rs`) with preferred biome arrays and water avoidance. Adjust `MovementSpeed` handling so slopes slow heavier animals.\n\nPseudo-code:\n```rust\nlet biome = world_loader.get_biome_at(x, y);\nlet base_cost = terrain_cost(terrain);\nlet species_bias = behavior.preferred_biome_cost(biome);\npathfinding_grid.set_cost(pos, base_cost + species_bias + slope_penalty(elevation_gradient));\n```\n\nEnsure fleeing logic respects riparian hazards.",
        "testStrategy": "Add unit tests for new cost calculators using mocked terrain/biome inputs. Create integration tests that instantiate a small world and assert species choose lower-cost tiles matching preferences. Run `cargo test pathfinding` and execute the simulator with debug logs to validate runtime behavior.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Enhance species AI with new ecological parameters",
        "description": "Incorporate hunt range, fear thresholds, and reproduction tuning per PRD into the existing utility-based AI systems.",
        "details": "Extend `BehaviorConfig` and `SpeciesNeeds` in `src/entities/types/*.rs` to include `hunt_range`, `preferred_biome`, and updated rates from the PRD. Update AI utility calculations in `src/ai/` (e.g., `predator_toolkit.rs`, `herbivore_toolkit.rs`) to consider biome proximity, water search radius, and fleeing urgency. Introduce pack hunting scaffolding for wolves and improved scavenging for omnivores, storing new actions in `ActionQueue`.\n\nPseudo-code:\n```rust\nif predator && prey_distance <= config.hunt_range {\n    actions.push(Action::Hunt { target, terrain_bias: biome_cost });\n}\nif fear_trigger && current_biome != config.preferred_biome {\n    actions.push(Action::RelocateToBiome { biome: config.preferred_biome });\n}\n```\n\nKeep systems data-driven so future species can plug in configuration files.",
        "testStrategy": "Add focused AI tests using Bevy `App::new()` with mocked entities to ensure new considerations change action priorities as expected. Simulate 10k ticks headless with logging to verify predators don’t overhunt and herbivores find food/water. Capture metrics before/after to confirm improvements.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Expand HTTP API with biome, elevation, and ecological statistics",
        "description": "Expose new world layers and population metrics through the REST API for tooling and the Godot viewer.",
        "details": "Update `src/web_server_simple.rs` (and `web_server.rs` if used) to add `/api/biomes`, enhanced `/api/statistics`, and enriched `/api/chunks` responses including biome, elevation, vegetation density, and river metadata. Integrate simulation event tracking (births, deaths, predation) into a statistics resource and serialize to JSON aligned with PRD requirements.\n\nPseudo-code:\n```rust\nfn handle_get_biomes(...) -> HttpResponse {\n    let summary = cached_world.biome_summary();\n    respond_json(json!({ \"coverage\": summary.coverage_map, \"river\": summary.river_stats }));\n}\n\nfn handle_get_statistics(...) {\n    let stats = ecosystem_tracker.snapshot();\n    respond_json(stats);\n}\n```\n\nDocument the endpoints for viewer integration.",
        "testStrategy": "Add HTTP layer tests using `reqwest` in a `#[tokio::test]` targeting the in-process server to assert JSON schemas. Run simulator + server and curl the endpoints to verify live data. Include schema validation in CI by comparing against expected keys.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Upgrade Godot viewer rendering for advanced biomes and overlays",
        "description": "Implement the isometric visualization pipeline that showcases new biomes, rivers, vegetation, and statistics overlays.",
        "details": "In `godot-viewer/scripts/`, extend `TerrainTileMap.gd` and `ResourceManager.gd` to render biome-specific palettes, elevation shading, and water animations (flow shader). Add `WorldDataCache.gd` support for new API responses, update `StatisticsHUD.gd` with population graphs, and implement toggleable overlays (biome coverage, riparian zones). Introduce camera polish (smooth zoom, entity follow) per PRD.\n\nPseudo-code:\n```gdscript\nvar biome = world_data_cache.get_biome(tile_pos)\nvar tile_color = BiomePalette.get_color(biome, elevation)\nterrain_tilemap.set_cellv(tile_pos, tile_id_for(biome))\nresource_manager.render_resources(tile_pos, vegetation_density[tile_pos])\nstatistics_hud.update_population_charts(snapshot.population_by_species)\n```\n\nEnsure assets (tile atlases, shaders) live under `godot-viewer/resources/` and reuse existing tooling.",
        "testStrategy": "Add Godot `--headless` tests (via `--script`) that load scenes, mock HTTP data, and assert tilemaps materialize expected tiles. Manually run the viewer against a generated world to confirm performance and visual targets (60 FPS, smooth overlays). Capture screenshots for regression baselines.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-13T17:37:03.677Z",
      "updated": "2025-10-13T17:37:03.677Z",
      "description": "Tasks for master context"
    }
  }
}